<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frog Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #282c34;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .info-panel:hover {
            opacity: 1;
        }
        .info-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #8bd5ca;
        }
        .info-panel p {
            margin: 5px 0;
        }
        .info-panel a {
            color: #61afef;
            text-decoration: none;
            transition: color 0.2s;
        }
        .info-panel a:hover {
            color: #c678dd;
            text-decoration: underline;
        }
        .github-corner {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
        }
        .github-corner svg {
            fill: #61afef;
            color: #282c34;
            transition: fill 0.3s;
        }
        .github-corner:hover svg {
            fill: #c678dd;
        }
        .minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 16px;
        }
        .minimize-btn:hover {
            color: white;
        }
        .show-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
        .motion-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            font-family: inherit;
            transition: background-color 0.3s;
        }
        .motion-btn:hover {
            background-color: rgba(50, 50, 50, 0.9);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <a href="https://github.com/davidroman0O/soft-body-frog" class="github-corner" aria-label="View on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    
    <button id="motion-btn" class="motion-btn">Enable Motion Controls</button>
    
    <div id="info-panel" class="info-panel">
        <button id="minimize-btn" class="minimize-btn">Ã—</button>
        <h3>Soft Body Frog Animation</h3>
        <p>A JavaScript port of the Soft Body Frog procedural animation.</p>
        <p>Drag/click on the frog to interact with it!</p>
        <p>Try tilting your device to see the frog respond to gravity!</p>
        <p><strong>Based on:</strong></p>
        <ul>
            <li>Original creator: <a href="https://www.youtube.com/@argonautcode" target="_blank">@argonautcode</a></li>
            <li>Tutorial video: <a href="https://www.youtube.com/watch?v=GXh0Vxg7AnQ" target="_blank">Procedural Frog Animation</a></li>
            <li>Original code: <a href="https://github.com/argonautcode/soft-body-proc-anim" target="_blank">soft-body-proc-anim</a></li>
        </ul>
        <p><strong>JavaScript port:</strong> <a href="https://github.com/davidroman0O/soft-body-frog" target="_blank">davidroman0O/soft-body-frog</a></p>
    </div>
    
    <div id="show-info" class="show-info">Show Info</div>
    
    <script>
        // Constants
        const PI = Math.PI;
        const TWO_PI = Math.PI * 2;
        const HALF_PI = Math.PI / 2;

        // Global variables
        let canvas, ctx;
        let frog;
        let mouseX = 0, mouseY = 0;
        let mousePressed = false;
        let useDeviceMotion = false;
        let gravitySensor = { x: 0, y: 1 }; // Default gravity is downward

        // Utility functions
        function constrain(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Constrains the angle to be within a certain range of the anchor
        function constrainAngle(angle, anchor, constraint) {
            if (Math.abs(relativeAngleDiff(angle, anchor)) <= constraint) {
                return simplifyAngle(angle);
            }
            if (relativeAngleDiff(angle, anchor) > constraint) {
                return simplifyAngle(anchor - constraint);
            }
            return simplifyAngle(anchor + constraint);
        }

        // How many radians do you need to turn the angle to match the anchor?
        function relativeAngleDiff(angle, anchor) {
            angle = simplifyAngle(angle + PI - anchor);
            anchor = PI;
            return anchor - angle;
        }

        // Simplify the angle to be in the range [0, 2pi)
        function simplifyAngle(angle) {
            while (angle >= TWO_PI) {
                angle -= TWO_PI;
            }
            while (angle < 0) {
                angle += TWO_PI;
            }
            return angle;
        }

        // Vector2 class (equivalent to PVector in Processing)
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            copy() {
                return new Vector2(this.x, this.y);
            }

            add(x, y) {
                if (y === undefined) {
                    // Vector was passed
                    this.x += x.x;
                    this.y += x.y;
                } else {
                    this.x += x;
                    this.y += y;
                }
                return this;
            }

            sub(x, y) {
                if (y === undefined) {
                    // Vector was passed
                    this.x -= x.x;
                    this.y -= x.y;
                } else {
                    this.x -= x;
                    this.y -= y;
                }
                return this;
            }

            mult(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }

            div(scalar) {
                if (scalar !== 0) {
                    this.x /= scalar;
                    this.y /= scalar;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            setMag(magnitude) {
                const currentMag = this.mag();
                if (currentMag !== 0) {
                    this.mult(magnitude / currentMag);
                }
                return this;
            }

            heading() {
                return Math.atan2(this.y, this.x);
            }

            rotate(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const x = this.x * cos - this.y * sin;
                const y = this.x * sin + this.y * cos;
                this.x = x;
                this.y = y;
                return this;
            }

            // Static methods
            static add(v1, v2) {
                return new Vector2(v1.x + v2.x, v1.y + v2.y);
            }

            static sub(v1, v2) {
                return new Vector2(v1.x - v2.x, v1.y - v2.y);
            }

            static dist(v1, v2) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            static fromAngle(angle) {
                return new Vector2(Math.cos(angle), Math.sin(angle));
            }

            static lerp(v1, v2, t) {
                return new Vector2(
                    v1.x + (v2.x - v1.x) * t,
                    v1.y + (v2.y - v1.y) * t
                );
            }
        }

        // BlobPoint class for the soft body simulation
        class BlobPoint {
            constructor(pos) {
                this.pos = pos.copy();
                this.ppos = pos.copy(); // previous pos
                this.displacement = new Vector2(0, 0);
                this.displacementWeight = 0;
            }

            verletIntegrate() {
                const temp = this.pos.copy();
                const vel = Vector2.sub(this.pos, this.ppos).mult(0.99); // Slightly dampen velocity
                this.pos.add(vel);
                this.ppos = temp;
            }

            applyGravity() {
                this.pos.add(gravitySensor.x, gravitySensor.y);
            }

            accumulateDisplacement(offset) {
                this.displacement.add(offset);
                this.displacementWeight += 1;
            }

            applyDisplacement() {
                if (this.displacementWeight > 0) {
                    this.displacement.div(this.displacementWeight);
                    this.pos.add(this.displacement);
                    this.displacement = new Vector2(0, 0);
                    this.displacementWeight = 0;
                }
            }

            keepInBounds() {
                this.pos.x = constrain(this.pos.x, 0, canvas.width);
                this.pos.y = constrain(this.pos.y, 0, canvas.height);
            }

            collideWithMouse() {
                const mouse = new Vector2(mouseX, mouseY);
                if (mousePressed && Vector2.dist(this.pos, mouse) < 100) {
                    const diff = Vector2.sub(this.pos, mouse).setMag(100);
                    this.pos = Vector2.add(mouse, diff);
                }
            }
        }

        // Blob class for the frog's body
        class Blob {
            constructor(origin, numPoints, radius, puffiness) {
                this.radius = radius;
                this.area = radius * radius * PI * puffiness;
                this.circumference = radius * TWO_PI;
                this.chordLength = this.circumference / numPoints;

                this.points = [];
                for (let i = 0; i < numPoints; i++) {
                    const offset = new Vector2(
                        Math.cos(TWO_PI * i / numPoints - HALF_PI) * radius,
                        Math.sin(TWO_PI * i / numPoints - HALF_PI) * radius
                    );
                    this.points.push(new BlobPoint(Vector2.add(origin, offset)));
                }
            }

            update() {
                // Compute one time step of physics with Verlet integration
                for (const point of this.points) {
                    point.verletIntegrate();
                    point.applyGravity();
                }

                // Iterate multiple times to converge faster
                for (let j = 0; j < 10; j++) {
                    // Accumulate displacement caused by distance constraints
                    for (let i = 0; i < this.points.length; i++) {
                        const cur = this.points[i];
                        const next = this.points[i === this.points.length - 1 ? 0 : i + 1];

                        const diff = Vector2.sub(next.pos, cur.pos);
                        // Only constrain points if they are too far from each other
                        if (diff.mag() > this.chordLength) {
                            // Both points equally pulled together to correct error
                            const error = (diff.mag() - this.chordLength) / 2;
                            const offset = diff.copy().setMag(error);
                            const negOffset = offset.copy().mult(-1);
                            cur.accumulateDisplacement(offset);
                            next.accumulateDisplacement(negOffset);
                        }
                    }

                    // Accumulate displacement caused by dilation (preventing squashing)
                    const error = this.area - this.getArea();
                    const offset = error / this.circumference;

                    for (let i = 0; i < this.points.length; i++) {
                        // Push along normal from secant line of neighbors
                        const prev = this.points[i === 0 ? this.points.length - 1 : i - 1];
                        const cur = this.points[i];
                        const next = this.points[i === this.points.length - 1 ? 0 : i + 1];
                        const secant = Vector2.sub(next.pos, prev.pos);
                        const normal = secant.copy().rotate(-HALF_PI).setMag(offset);
                        cur.accumulateDisplacement(normal);
                    }

                    // Apply all accumulated displacement
                    for (const point of this.points) {
                        point.applyDisplacement();
                    }

                    // Collision detection
                    for (const point of this.points) {
                        point.keepInBounds();
                        point.collideWithMouse();
                    }
                }
            }

            // Get area using trapezoid method
            getArea() {
                let area = 0;
                for (let i = 0; i < this.points.length; i++) {
                    const cur = this.points[i].pos;
                    const next = this.points[i === this.points.length - 1 ? 0 : i + 1].pos;
                    area += ((cur.x - next.x) * (cur.y + next.y) / 2);
                }
                return area;
            }
        }

        // LimbPoint class for joints
        class LimbPoint {
            constructor(pos) {
                this.pos = pos.copy();
                this.ppos = pos.copy();
                this.angle = 0;
            }

            verletIntegrate() {
                const temp = this.pos.copy();
                const vel = Vector2.sub(this.pos, this.ppos).mult(0.95);
                this.pos.add(vel);
                this.ppos = temp;
            }

            applyConstraint(anchor, normal, distance, angleRange, angleOffset) {
                const anchorAngle = normal + angleOffset;
                const curAngle = Vector2.sub(anchor, this.pos).heading();
                this.angle = constrainAngle(curAngle, anchorAngle, angleRange);
                this.pos = Vector2.sub(anchor, Vector2.fromAngle(this.angle).setMag(distance));
            }

            applyGravity() {
                this.pos.add(gravitySensor.x, gravitySensor.y);
            }

            keepInBounds() {
                this.pos.x = constrain(this.pos.x, 0, canvas.width);
                this.pos.y = constrain(this.pos.y, 0, canvas.height);
            }
        }

        // Limb class for legs
        class Limb {
            constructor(origin, distance, elbowRange, elbowOffset, footRange, footOffset) {
                this.distance = distance;
                this.elbowRange = elbowRange;
                this.elbowOffset = elbowOffset;
                this.footRange = footRange;
                this.footOffset = footOffset;
                this.elbow = new LimbPoint(Vector2.add(origin, new Vector2(0, distance)));
                this.foot = new LimbPoint(Vector2.add(this.elbow.pos, new Vector2(0, distance)));
            }

            resolve(anchor, normal) {
                this.elbow.verletIntegrate();
                this.elbow.applyGravity();
                this.elbow.applyConstraint(anchor, normal, this.distance, this.elbowRange, this.elbowOffset);
                this.elbow.keepInBounds();

                this.foot.verletIntegrate();
                this.foot.applyGravity();
                this.foot.applyConstraint(this.elbow.pos, this.elbow.angle, this.distance, this.footRange, this.footOffset);
                this.foot.keepInBounds();
            }
        }

        // Frog class that combines all components
        class Frog {
            constructor(origin) {
                this.blob = new Blob(origin, 16, 128, 1.5);
                this.leftFrontLeg = new Limb(Vector2.sub(origin, new Vector2(80, 0)), 56, PI/4, PI/8, PI/5, -PI/4);
                this.rightFrontLeg = new Limb(Vector2.sub(origin, new Vector2(-80, 0)), 56, PI/4, -PI/8, PI/5, PI/4);
                this.leftHindLeg = new Limb(Vector2.sub(origin, new Vector2(100, 0)), 100, 1.9*PI/5, 2*PI/5, 2*PI/5, -2*PI/5);
                this.rightHindLeg = new Limb(Vector2.sub(origin, new Vector2(-100, 0)), 100, 1.9*PI/5, -2*PI/5, 2*PI/5, 2*PI/5);
            }

            update() {
                this.blob.update();

                const leftFront = this.blob.points[12].pos;
                const rightFront = this.blob.points[4].pos;
                const leftFrontAnchor = Vector2.lerp(leftFront, rightFront, 0.25).add(new Vector2(0, 10));
                const rightFrontAnchor = Vector2.lerp(leftFront, rightFront, 0.75).add(new Vector2(0, 10));
                const midSecant = Vector2.sub(rightFront, leftFront).setMag(64);
                const midNormal = midSecant.copy().rotate(-HALF_PI).heading();
                const leftHindAnchor = Vector2.add(this.blob.points[11].pos, midSecant).add(new Vector2(0, 16));
                const rightHindAnchor = Vector2.sub(this.blob.points[5].pos, midSecant).add(new Vector2(0, 16));

                this.leftFrontLeg.resolve(leftFrontAnchor, midNormal);
                this.rightFrontLeg.resolve(rightFrontAnchor, midNormal);

                // Hack to make hind legs go back into position when approaching ground
                if (canvas.height - this.leftHindLeg.foot.pos.y < 100) {
                    this.leftHindLeg.elbow.pos.y -= 1.5;
                    this.leftHindLeg.foot.pos.x += 0.5;
                }
                if (canvas.height - this.rightHindLeg.foot.pos.y < 100) {
                    this.rightHindLeg.elbow.pos.y -= 1.5;
                    this.rightHindLeg.foot.pos.x -= 0.5;
                }

                this.leftHindLeg.resolve(leftHindAnchor, midNormal);
                this.rightHindLeg.resolve(rightHindAnchor, midNormal);
            }

            display() {
                this.drawHindLegs();
                this.drawBody();
                this.drawHead();
                this.drawFrontLegs();
            }

            drawCurve(points, close = false) {
                // Draw a smooth curve through the points
                if (points.length < 2) return;
                
                ctx.beginPath();
                
                // Create tension for the curve
                const tension = 0.5;
                
                // Draw beginning
                ctx.moveTo(points[0].x, points[0].y);
                
                // Use bezier curves to approximate cardinal spline
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = i > 0 ? points[i - 1] : points[0];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = i < points.length - 2 ? points[i + 2] : p2;
                    
                    // Calculate control points
                    const cp1x = p1.x + (p2.x - p0.x) * tension / 3;
                    const cp1y = p1.y + (p2.y - p0.y) * tension / 3;
                    const cp2x = p2.x - (p3.x - p1.x) * tension / 3;
                    const cp2y = p2.y - (p3.y - p1.y) * tension / 3;
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                }
                
                if (close) {
                    ctx.closePath();
                }
            }

            drawBody() {
                const points = this.blob.points.map(p => p.pos);
                
                // Create smooth closing for the curve
                const allPoints = [
                    points[points.length - 2],
                    points[points.length - 1],
                    ...points,
                    points[0],
                    points[1]
                ];
                
                ctx.lineWidth = 8;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(allPoints, true);
                ctx.fill();
                ctx.stroke();
            }

            drawHead() {
                const top = this.blob.points[0].pos;
                const topNormal = Vector2.sub(
                    this.blob.points[2].pos, 
                    this.blob.points[this.blob.points.length - 2].pos
                ).heading();

                ctx.save();
                ctx.translate(top.x, top.y);
                ctx.rotate(topNormal);

                // Head
                ctx.beginPath();
                ctx.arc(0, 75, 250/2, -PI, 0, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(0, 75, 244/2, 219/2, 0, 0, TWO_PI);
                ctx.fillStyle = 'rgb(85, 145, 127)';
                ctx.fill();

                // Eye socket thingies
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'black';
                
                ctx.beginPath();
                ctx.arc(-75, -10, 75/2, -PI-PI/4.6, -PI/5.6, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(75, -10, 75/2, -PI+PI/5.6, PI/4.6, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(-75, -10, 70/2, 70/2, 0, 0, TWO_PI);
                ctx.fillStyle = 'rgb(85, 145, 127)';
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(75, -10, 70/2, 70/2, 0, 0, TWO_PI);
                ctx.fill();

                // Eyes
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(240, 153, 91)';
                
                ctx.beginPath();
                ctx.ellipse(-75, -10, 48/2, 48/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(75, -10, 48/2, 48/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();

                // Pupils
                ctx.fillStyle = 'black';
                
                // Left pupil
                ctx.save();
                ctx.translate(-75, -10);
                ctx.rotate(-PI/24);
                ctx.beginPath();
                ctx.ellipse(0, 0, 32/2, 18/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Right pupil
                ctx.save();
                ctx.translate(75, -10);
                ctx.rotate(PI/24);
                ctx.beginPath();
                ctx.ellipse(0, 0, 32/2, 18/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();

                // Chin
                ctx.lineWidth = 7;
                ctx.strokeStyle = 'black';
                
                ctx.beginPath();
                ctx.arc(0, 80, 92/2, PI/8, PI-PI/8, false);
                ctx.stroke();

                // Mouth
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(-90, 40);
                ctx.bezierCurveTo(-45, 60, -35, 15, -10, 25);
                ctx.bezierCurveTo(-5, 27, 5, 27, 10, 25);
                ctx.bezierCurveTo(35, 15, 45, 60, 90, 40);
                ctx.stroke();

                // Nostrils
                ctx.fillStyle = 'black';
                
                // Left nostril
                ctx.save();
                ctx.translate(-9, 5);
                ctx.rotate(PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 0, 2/2, 5/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Right nostril
                ctx.save();
                ctx.translate(9, 5);
                ctx.rotate(-PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 0, 2/2, 5/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }

            drawFrontLegs() {
                const left = this.blob.points[12].pos;
                const right = this.blob.points[4].pos;
                const leftAnchor = Vector2.lerp(left, right, 0.25).add(new Vector2(0, 10));
                const rightAnchor = Vector2.lerp(left, right, 0.75).add(new Vector2(0, 10));
                this.drawFrontLeg(leftAnchor, this.leftFrontLeg);
                this.drawFrontLeg(rightAnchor, this.rightFrontLeg);
            }

            drawHindLegs() {
                const left = this.blob.points[12].pos;
                const right = this.blob.points[4].pos;
                const midSecant = Vector2.sub(right, left).setMag(64);
                const leftAnchor = Vector2.add(this.blob.points[11].pos, midSecant).add(new Vector2(0, 16));
                const rightAnchor = Vector2.sub(this.blob.points[5].pos, midSecant).add(new Vector2(0, 16));
                this.drawHindLeg(leftAnchor, this.leftHindLeg, false);
                this.drawHindLeg(rightAnchor, this.rightHindLeg, true);
            }

            drawFrontLeg(anchor, limb) {
                // Draw the outline
                ctx.lineWidth = 48;
                ctx.strokeStyle = 'black';
                
                const curvePoints = [
                    anchor,
                    anchor,
                    limb.elbow.pos,
                    limb.foot.pos,
                    limb.foot.pos
                ];
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw the fill
                ctx.lineWidth = 34;
                ctx.strokeStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw toes
                const footNormal = Vector2.sub(limb.elbow.pos, limb.foot.pos).heading() + HALF_PI;
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.save();
                ctx.translate(limb.foot.pos.x, limb.foot.pos.y);
                
                // First toe
                ctx.save();
                ctx.rotate(footNormal - PI/4);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Second toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Third toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Fourth toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 3*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Hide overlaps
                ctx.strokeStyle = 'transparent';
                
                // First overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Second overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Third overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4);
                ctx.beginPath();
                ctx.ellipse(0, 16, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                ctx.restore();

                // Hide limb-body connection
                const shoulderNormal = Vector2.sub(anchor, limb.elbow.pos).heading();
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.beginPath();
                ctx.arc(anchor.x, anchor.y, 49/2, -HALF_PI+shoulderNormal, HALF_PI+shoulderNormal);
                ctx.fill();

                // Hide toe-foot connection
                ctx.beginPath();
                ctx.ellipse(limb.foot.pos.x, limb.foot.pos.y, 35/2, 35/2, 0, 0, TWO_PI);
                ctx.fill();
            }

            drawHindLeg(anchor, limb, right) {
                const offset = right ? -PI/8 : PI/8;
                const footNormal = Vector2.sub(limb.elbow.pos, limb.foot.pos).heading() + HALF_PI + offset;
                const footShift = Vector2.add(limb.foot.pos, Vector2.fromAngle(footNormal + HALF_PI).setMag(24));
                
                // Draw the outline
                ctx.lineWidth = 48;
                ctx.strokeStyle = 'black';
                
                const curvePoints = [
                    anchor, 
                    anchor, 
                    limb.elbow.pos, 
                    limb.foot.pos, 
                    footShift, 
                    footShift
                ];
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw the fill
                ctx.lineWidth = 34;
                ctx.strokeStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw toes
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.save();
                ctx.translate(footShift.x, footShift.y);
                
                // First toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Second toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Third toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Fourth toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 3*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Hide overlaps
                ctx.strokeStyle = 'transparent';
                
                // First overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Second overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Third overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset);
                ctx.beginPath();
                ctx.ellipse(0, 16, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                ctx.restore();

                // Hide limb-body connection
                const shoulderNormal = Vector2.sub(anchor, limb.elbow.pos).heading();
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.beginPath();
                ctx.arc(anchor.x, anchor.y, 49/2, -HALF_PI+shoulderNormal, HALF_PI+shoulderNormal);
                ctx.fill();

                // Hide toe-foot connection
                ctx.beginPath();
                ctx.ellipse(footShift.x, footShift.y, 35/2, 35/2, 0, 0, TWO_PI);
                ctx.fill();
            }
        }

        // Initialize the application
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Make canvas fullscreen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Create the frog
            frog = new Frog(new Vector2(canvas.width / 2, canvas.height - 400));
            
            // Add mouse event listeners
            canvas.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mousedown', () => {
                mousePressed = true;
            });
            
            canvas.addEventListener('mouseup', () => {
                mousePressed = false;
            });
            
            // Add touch event listeners for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                mousePressed = true;
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouseX = touch.clientX;
                    mouseY = touch.clientY;
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouseX = touch.clientX;
                    mouseY = touch.clientY;
                }
            });
            
            canvas.addEventListener('touchend', () => {
                mousePressed = false;
            });
            
            canvas.addEventListener('touchcancel', () => {
                mousePressed = false;
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                frog = new Frog(new Vector2(canvas.width / 2, canvas.height - 400));
            });
            
            // Add motion toggle button event listener
            document.getElementById('motion-btn').addEventListener('click', toggleDeviceMotion);
            
            // Start animation loop
            requestAnimationFrame(animate);
        }

        // Device motion functions
        function requestDeviceMotionPermission() {
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ requires explicit permission
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            enableDeviceMotion();
                        }
                    })
                    .catch(console.error);
            } else {
                // Other devices don't need permission
                enableDeviceMotion();
            }
        }

        function enableDeviceMotion() {
            useDeviceMotion = true;
            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
            
            // Update UI
            const motionBtn = document.getElementById('motion-btn');
            motionBtn.innerText = 'Disable Motion Controls';
        }

        function disableDeviceMotion() {
            useDeviceMotion = false;
            window.removeEventListener('deviceorientation', handleOrientation);
            window.removeEventListener('devicemotion', handleMotion);
            
            // Reset gravity to default (down)
            gravitySensor = { x: 0, y: 1 };
            
            // Update UI
            const motionBtn = document.getElementById('motion-btn');
            motionBtn.innerText = 'Enable Motion Controls';
        }

        function toggleDeviceMotion() {
            if (useDeviceMotion) {
                disableDeviceMotion();
            } else {
                requestDeviceMotionPermission();
            }
        }

        function handleOrientation(event) {
            if (!useDeviceMotion) return;
            
            // Get orientation angles in degrees
            const beta = event.beta;  // -180 to 180 (front-to-back tilt)
            const gamma = event.gamma; // -90 to 90 (left-to-right tilt)
            
            // Convert to gravity vector with appropriate scaling
            gravitySensor.x = Math.sin(gamma * Math.PI / 180) * 1.5;
            gravitySensor.y = Math.sin(beta * Math.PI / 180) * 1.5;
            
            // Ensure minimum gravity for better physics
            if (Math.abs(gravitySensor.y) < 0.3) gravitySensor.y = 0.3 * Math.sign(gravitySensor.y);
        }

        function handleMotion(event) {
            if (!useDeviceMotion) return;
            
            // Get acceleration including gravity
            const accel = event.accelerationIncludingGravity;
            
            // Use acceleration if available (fallback to orientation-based gravity)
            if (accel && accel.x !== null && accel.y !== null) {
                // Scale acceleration for better physics feel
                gravitySensor.x = accel.x * 0.1;
                gravitySensor.y = accel.y * 0.1;
                
                // Ensure minimum gravity
                if (Math.abs(gravitySensor.y) < 0.3) gravitySensor.y = 0.3 * Math.sign(gravitySensor.y);
            }
        }

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.fillStyle = 'rgb(40, 44, 52)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and display frog
            frog.update();
            frog.display();
            
            // Continue animation
            requestAnimationFrame(animate);
        }

        // Start the application when page loads
        window.onload = init;
        
        // Handle info panel minimizing/maximizing
        document.addEventListener('DOMContentLoaded', function() {
            const infoPanel = document.getElementById('info-panel');
            const minimizeBtn = document.getElementById('minimize-btn');
            const showInfoBtn = document.getElementById('show-info');
            
            minimizeBtn.addEventListener('click', function() {
                infoPanel.style.display = 'none';
                showInfoBtn.style.display = 'block';
            });
            
            showInfoBtn.addEventListener('click', function() {
                infoPanel.style.display = 'block';
                showInfoBtn.style.display = 'none';
            });
            
            // Auto-hide info panel after 10 seconds, but only on desktop
            if (window.innerWidth > 768) {
                setTimeout(function() {
                    infoPanel.style.opacity = '0.3';
                }, 5000);
                
                infoPanel.addEventListener('mouseenter', function() {
                    infoPanel.style.opacity = '1';
                });
                
                infoPanel.addEventListener('mouseleave', function() {
                    infoPanel.style.opacity = '0.3';
                });
            }
            
            // Check if device has accelerometer/gyroscope capabilities
            if (window.DeviceMotionEvent || window.DeviceOrientationEvent) {
                document.getElementById('motion-btn').style.display = 'block';
            } else {
                document.getElementById('motion-btn').style.display = 'none';
            }
        });
    </script>
</body>
</html>