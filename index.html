<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Is it frog day or not?</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #282c34;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        .info-panel:hover {
            opacity: 1;
        }
        .info-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #8bd5ca;
        }
        .info-panel p {
            margin: 5px 0;
        }
        .info-panel a {
            color: #61afef;
            text-decoration: none;
            transition: color 0.2s;
        }
        .info-panel a:hover {
            color: #c678dd;
            text-decoration: underline;
        }
        .github-corner {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
        }
        .github-corner svg {
            fill: #61afef;
            color: #282c34;
            transition: fill 0.3s;
        }
        .github-corner:hover svg {
            fill: #c678dd;
        }
        .minimize-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 16px;
        }
        .minimize-btn:hover {
            color: white;
        }
        .show-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            display: none;
        }
        .motion-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            font-family: inherit;
            transition: background-color 0.3s;
        }
        .motion-btn:hover {
            background-color: rgba(50, 50, 50, 0.9);
        }
        
        /* Splash screen styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(40, 44, 52, 0.98);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        .splash-content {
            max-width: 500px;
            text-align: center;
            padding: 30px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        }
        .splash-content h1 {
            color: #8bd5ca;
            font-size: 2.5rem;
            margin-bottom: 15px;
        }
        .splash-content p {
            color: white;
            font-size: 1rem;
            margin-bottom: 25px;
            line-height: 1.5;
        }
        #start-button {
            background-color: #61afef;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        #start-button:hover {
            background-color: #c678dd;
            transform: scale(1.05);
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="splash-screen" class="splash-screen">
        <div class="splash-content">
            <h1>Soft Body Frog</h1>
            <p>A physics-based frog animation that responds to interaction and makes sounds!</p>
            <button id="start-button">Start Animation</button>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    <!-- Audio elements for frog sounds -->
    <audio id="croak-sound" preload="auto" src="frog-ribbit.mp3"></audio>
    <audio id="wednesday-sound" preload="auto" src="wednesday-my-dudes.mp3"></audio>
    <audio id="scream-sound" preload="auto" src="aaaaah.mp3"></audio>
    <!-- Silent audio for unlocking audio context -->
    <audio id="silent-audio" preload="auto" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjMyLjEwNAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAADQgD///////////////////////////////////////////8AAAA8TEFNRTMuMTAwAQAAAAAAAAAAABSAJAJAQgAAgAAAA0L2YLwxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV" type="audio/mp3"></audio>
    <!-- Silent audio for unlocking audio context -->
    
    <a href="https://github.com/davidroman0O/frog-procedural-soft-body" class="github-corner" aria-label="View on GitHub">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
            <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    
    <button id="motion-btn" class="motion-btn">Enable Motion Controls</button>
    
    <div id="info-panel" class="info-panel">
        <button id="minimize-btn" class="minimize-btn">Ã—</button>
        <h3>Soft Body Frog Animation</h3>
        <p>A JavaScript port of the Soft Body Frog procedural animation.</p>
        <p>Drag/click on the frog to interact with it!</p>
        <p>Try tilting your device to see the frog respond to gravity!</p>
        <p>Listen for the occasional ribbit sounds!</p>
        <p id="wednesday-text" style="display: none; font-weight: bold; color: #ffcc00;">It is Wednesday my dudes!</p>
        <p><strong>Based on:</strong></p>
        <ul>
            <li>Original creator: <a href="https://www.youtube.com/@argonautcode" target="_blank">@argonautcode</a></li>
            <li>Tutorial video: <a href="https://www.youtube.com/watch?v=GXh0Vxg7AnQ" target="_blank">Procedural Frog Animation</a></li>
            <li>Original code: <a href="https://github.com/argonautcode/soft-body-proc-anim" target="_blank">soft-body-proc-anim</a></li>
        </ul>
        <p><strong>JavaScript port:</strong> <a href="https://github.com/davidroman0O/frog-procedural-soft-body" target="_blank">davidroman0O/frog-procedural-soft-body</a></p>
    </div>
    
    <div id="show-info" class="show-info">Show Info</div>
    
    <script>
        // Constants
        const PI = Math.PI;
        const TWO_PI = Math.PI * 2;
        const HALF_PI = Math.PI / 2;

        // Global variables
        let canvas, ctx;
        let frog;
        let mouseX = 0, mouseY = 0;
        let prevMouseX = 0, prevMouseY = 0;
        let mouseSpeed = 0;
        let mousePressed = false;
        // Global variables for motion controls
        let useDeviceMotion = false;
        let gravitySensor = { x: 0, y: 1 }; // Default gravity is downward
        let prevGravitySensor = { x: 0, y: 1 };
        let gravityChangeSpeed = 0;
        let lastGravityCheckTime = 0;
        let GRAVITY_CHECK_INTERVAL = 100; // Check gravity changes every 100ms
        let GRAVITY_CHANGE_THRESHOLD = 0.3; // Minimum change to trigger scream check
        
        // Global variables for touch tracking
        let touchStartX = 0, touchStartY = 0;
        let touchMoveX = 0, touchMoveY = 0;
        let touchActive = false;
        let touchDragDistance = 0;
        let touchDragSpeed = 0;
        let touchDragStartTime = 0;
        let lastTouchMoveTime = 0;
        let isMobile = false; // Will be set based on device detection
        
        // Animation timing and behavior variables - easy to adjust
        let MIN_BLINK_DELAY = 2000;  // Minimum time between blinks (ms)
        let MAX_BLINK_DELAY = 7000;  // Maximum time between blinks (ms)
        let MIN_CROAK_DELAY = 8000;  // Minimum time between croaks (ms)
        let MAX_CROAK_DELAY = 20000; // Maximum time between croaks (ms)
        let CLICK_CROAK_CHANCE = 0.3; // Probability of croaking when clicked (0-1)
        let DOUBLE_CROAK_CHANCE = 0.3; // Probability of a double-croak (0-1)
        let MOUSE_SPEED_THRESHOLD = 80; // Speed needed to trigger scream on desktop (increased from 50)
        let TOUCH_SPEED_THRESHOLD = 800; // Speed needed to trigger scream on mobile (reduced from 1200)
        let FROG_MOVEMENT_THRESHOLD = 2; // Minimum actual frog movement to trigger scream (reduced from 3)
        
        // Wednesday mode controls - SET THESE FOR TESTING
        let WEDNESDAY_ENABLED = true; // Enable Wednesday features
        let WEDNESDAY_OVERRIDE = false; // Force Wednesday mode regardless of actual day
        
        // Scream controls
        let SCREAM_ENABLED = true; // Enable scream on fast movement
        let SCREAM_COOLDOWN = 2000; // Minimum time between screams (ms) (increased from 1000)
        let lastScreamTime = 0; // Track when the last scream occurred
        
        // Debug flags
        let DEBUG_AUDIO = true; // Log audio-related debugging info
        
        // Eye animation variables
        let leftEyeOpen = 1.0;  // 1.0 = fully open, 0.0 = closed
        let rightEyeOpen = 1.0;
        let blinkInProgress = false;
        let lastBlinkTime = 0;
        let nextBlinkDelay = 0;
        
        // Croaking animation variables
        let mouthOpenness = 0.0; // 0.0 = closed, 1.0 = fully open
        let throatExpansion = 0.0; // 0.0 = normal, 1.0 = fully expanded
        let croakInProgress = false;
        let lastCroakTime = 0;
        let nextCroakDelay = 0;
        let croakSound; // Audio element for the croak sound
        let wednesdaySound; // Audio element for Wednesday sound
        let screamSound; // Audio element for the scream sound
        let isWednesday = false; // Flag to check if it's Wednesday
        
        // Speech syncing variables
        let speechKeyframes = []; // For mouth sync with speech audio
        let currentSpeechKeyframe = 0;

        // Utility functions
        function constrain(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        // Constrains the angle to be within a certain range of the anchor
        function constrainAngle(angle, anchor, constraint) {
            if (Math.abs(relativeAngleDiff(angle, anchor)) <= constraint) {
                return simplifyAngle(angle);
            }
            if (relativeAngleDiff(angle, anchor) > constraint) {
                return simplifyAngle(anchor - constraint);
            }
            return simplifyAngle(anchor + constraint);
        }

        // How many radians do you need to turn the angle to match the anchor?
        function relativeAngleDiff(angle, anchor) {
            angle = simplifyAngle(angle + PI - anchor);
            anchor = PI;
            return anchor - angle;
        }

        // Simplify the angle to be in the range [0, 2pi)
        function simplifyAngle(angle) {
            while (angle >= TWO_PI) {
                angle -= TWO_PI;
            }
            while (angle < 0) {
                angle += TWO_PI;
            }
            return angle;
        }

        // Vector2 class (equivalent to PVector in Processing)
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            copy() {
                return new Vector2(this.x, this.y);
            }

            add(x, y) {
                if (y === undefined) {
                    // Vector was passed
                    this.x += x.x;
                    this.y += x.y;
                } else {
                    this.x += x;
                    this.y += y;
                }
                return this;
            }

            sub(x, y) {
                if (y === undefined) {
                    // Vector was passed
                    this.x -= x.x;
                    this.y -= x.y;
                } else {
                    this.x -= x;
                    this.y -= y;
                }
                return this;
            }

            mult(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }

            div(scalar) {
                if (scalar !== 0) {
                    this.x /= scalar;
                    this.y /= scalar;
                }
                return this;
            }

            mag() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            setMag(magnitude) {
                const currentMag = this.mag();
                if (currentMag !== 0) {
                    this.mult(magnitude / currentMag);
                }
                return this;
            }

            heading() {
                return Math.atan2(this.y, this.x);
            }

            rotate(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const x = this.x * cos - this.y * sin;
                const y = this.x * sin + this.y * cos;
                this.x = x;
                this.y = y;
                return this;
            }

            // Static methods
            static add(v1, v2) {
                return new Vector2(v1.x + v2.x, v1.y + v2.y);
            }

            static sub(v1, v2) {
                return new Vector2(v1.x - v2.x, v1.y - v2.y);
            }

            static dist(v1, v2) {
                const dx = v2.x - v1.x;
                const dy = v2.y - v1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            static fromAngle(angle) {
                return new Vector2(Math.cos(angle), Math.sin(angle));
            }

            static lerp(v1, v2, t) {
                return new Vector2(
                    v1.x + (v2.x - v1.x) * t,
                    v1.y + (v2.y - v1.y) * t
                );
            }
        }

        // BlobPoint class for the soft body simulation
        class BlobPoint {
            constructor(pos) {
                this.pos = pos.copy();
                this.ppos = pos.copy(); // previous pos
                this.displacement = new Vector2(0, 0);
                this.displacementWeight = 0;
            }

            verletIntegrate() {
                const temp = this.pos.copy();
                const vel = Vector2.sub(this.pos, this.ppos).mult(0.99); // Slightly dampen velocity
                this.pos.add(vel);
                this.ppos = temp;
            }

            applyGravity() {
                this.pos.add(gravitySensor.x, gravitySensor.y);
            }

            accumulateDisplacement(offset) {
                this.displacement.add(offset);
                this.displacementWeight += 1;
            }

            applyDisplacement() {
                if (this.displacementWeight > 0) {
                    this.displacement.div(this.displacementWeight);
                    this.pos.add(this.displacement);
                    this.displacement = new Vector2(0, 0);
                    this.displacementWeight = 0;
                }
            }

            keepInBounds() {
                this.pos.x = constrain(this.pos.x, 0, canvas.width);
                this.pos.y = constrain(this.pos.y, 0, canvas.height);
            }

            collideWithMouse() {
                const mouse = new Vector2(mouseX, mouseY);
                if (mousePressed && Vector2.dist(this.pos, mouse) < 100) {
                    const diff = Vector2.sub(this.pos, mouse).setMag(100);
                    this.pos = Vector2.add(mouse, diff);
                }
            }
        }

        // Blob class for the frog's body
        class Blob {
            constructor(origin, numPoints, radius, puffiness) {
                this.radius = radius;
                this.area = radius * radius * PI * puffiness;
                this.circumference = radius * TWO_PI;
                this.chordLength = this.circumference / numPoints;

                this.points = [];
                for (let i = 0; i < numPoints; i++) {
                    const offset = new Vector2(
                        Math.cos(TWO_PI * i / numPoints - HALF_PI) * radius,
                        Math.sin(TWO_PI * i / numPoints - HALF_PI) * radius
                    );
                    this.points.push(new BlobPoint(Vector2.add(origin, offset)));
                }
            }

            update() {
                // Compute one time step of physics with Verlet integration
                for (const point of this.points) {
                    point.verletIntegrate();
                    point.applyGravity();
                }

                // Iterate multiple times to converge faster
                for (let j = 0; j < 10; j++) {
                    // Accumulate displacement caused by distance constraints
                    for (let i = 0; i < this.points.length; i++) {
                        const cur = this.points[i];
                        const next = this.points[i === this.points.length - 1 ? 0 : i + 1];

                        const diff = Vector2.sub(next.pos, cur.pos);
                        // Only constrain points if they are too far from each other
                        if (diff.mag() > this.chordLength) {
                            // Both points equally pulled together to correct error
                            const error = (diff.mag() - this.chordLength) / 2;
                            const offset = diff.copy().setMag(error);
                            const negOffset = offset.copy().mult(-1);
                            cur.accumulateDisplacement(offset);
                            next.accumulateDisplacement(negOffset);
                        }
                    }

                    // Accumulate displacement caused by dilation (preventing squashing)
                    const error = this.area - this.getArea();
                    const offset = error / this.circumference;

                    for (let i = 0; i < this.points.length; i++) {
                        // Push along normal from secant line of neighbors
                        const prev = this.points[i === 0 ? this.points.length - 1 : i - 1];
                        const cur = this.points[i];
                        const next = this.points[i === this.points.length - 1 ? 0 : i + 1];
                        const secant = Vector2.sub(next.pos, prev.pos);
                        const normal = secant.copy().rotate(-HALF_PI).setMag(offset);
                        cur.accumulateDisplacement(normal);
                    }

                    // Apply all accumulated displacement
                    for (const point of this.points) {
                        point.applyDisplacement();
                    }

                    // Collision detection
                    for (const point of this.points) {
                        point.keepInBounds();
                        point.collideWithMouse();
                    }
                }
            }

            // Get area using trapezoid method
            getArea() {
                let area = 0;
                for (let i = 0; i < this.points.length; i++) {
                    const cur = this.points[i].pos;
                    const next = this.points[i === this.points.length - 1 ? 0 : i + 1].pos;
                    area += ((cur.x - next.x) * (cur.y + next.y) / 2);
                }
                return area;
            }
        }

        // LimbPoint class for joints
        class LimbPoint {
            constructor(pos) {
                this.pos = pos.copy();
                this.ppos = pos.copy();
                this.angle = 0;
            }

            verletIntegrate() {
                const temp = this.pos.copy();
                const vel = Vector2.sub(this.pos, this.ppos).mult(0.95);
                this.pos.add(vel);
                this.ppos = temp;
            }

            applyConstraint(anchor, normal, distance, angleRange, angleOffset) {
                const anchorAngle = normal + angleOffset;
                const curAngle = Vector2.sub(anchor, this.pos).heading();
                this.angle = constrainAngle(curAngle, anchorAngle, angleRange);
                this.pos = Vector2.sub(anchor, Vector2.fromAngle(this.angle).setMag(distance));
            }

            applyGravity() {
                this.pos.add(gravitySensor.x, gravitySensor.y);
            }

            keepInBounds() {
                this.pos.x = constrain(this.pos.x, 0, canvas.width);
                this.pos.y = constrain(this.pos.y, 0, canvas.height);
            }
        }

        // Limb class for legs
        class Limb {
            constructor(origin, distance, elbowRange, elbowOffset, footRange, footOffset) {
                this.distance = distance;
                this.elbowRange = elbowRange;
                this.elbowOffset = elbowOffset;
                this.footRange = footRange;
                this.footOffset = footOffset;
                this.elbow = new LimbPoint(Vector2.add(origin, new Vector2(0, distance)));
                this.foot = new LimbPoint(Vector2.add(this.elbow.pos, new Vector2(0, distance)));
            }

            resolve(anchor, normal) {
                this.elbow.verletIntegrate();
                this.elbow.applyGravity();
                this.elbow.applyConstraint(anchor, normal, this.distance, this.elbowRange, this.elbowOffset);
                this.elbow.keepInBounds();

                this.foot.verletIntegrate();
                this.foot.applyGravity();
                this.foot.applyConstraint(this.elbow.pos, this.elbow.angle, this.distance, this.footRange, this.footOffset);
                this.foot.keepInBounds();
            }
        }

        // Frog class that combines all components
        class Frog {
            constructor(origin) {
                this.blob = new Blob(origin, 16, 128, 1.5);
                this.leftFrontLeg = new Limb(Vector2.sub(origin, new Vector2(80, 0)), 56, PI/4, PI/8, PI/5, -PI/4);
                this.rightFrontLeg = new Limb(Vector2.sub(origin, new Vector2(-80, 0)), 56, PI/4, -PI/8, PI/5, PI/4);
                this.leftHindLeg = new Limb(Vector2.sub(origin, new Vector2(100, 0)), 100, 1.9*PI/5, 2*PI/5, 2*PI/5, -2*PI/5);
                this.rightHindLeg = new Limb(Vector2.sub(origin, new Vector2(-100, 0)), 100, 1.9*PI/5, -2*PI/5, 2*PI/5, 2*PI/5);
            }

            update() {
                this.blob.update();

                const leftFront = this.blob.points[12].pos;
                const rightFront = this.blob.points[4].pos;
                const leftFrontAnchor = Vector2.lerp(leftFront, rightFront, 0.25).add(new Vector2(0, 10));
                const rightFrontAnchor = Vector2.lerp(leftFront, rightFront, 0.75).add(new Vector2(0, 10));
                const midSecant = Vector2.sub(rightFront, leftFront).setMag(64);
                const midNormal = midSecant.copy().rotate(-HALF_PI).heading();
                const leftHindAnchor = Vector2.add(this.blob.points[11].pos, midSecant).add(new Vector2(0, 16));
                const rightHindAnchor = Vector2.sub(this.blob.points[5].pos, midSecant).add(new Vector2(0, 16));

                this.leftFrontLeg.resolve(leftFrontAnchor, midNormal);
                this.rightFrontLeg.resolve(rightFrontAnchor, midNormal);

                // Hack to make hind legs go back into position when approaching ground
                if (canvas.height - this.leftHindLeg.foot.pos.y < 100) {
                    this.leftHindLeg.elbow.pos.y -= 1.5;
                    this.leftHindLeg.foot.pos.x += 0.5;
                }
                if (canvas.height - this.rightHindLeg.foot.pos.y < 100) {
                    this.rightHindLeg.elbow.pos.y -= 1.5;
                    this.rightHindLeg.foot.pos.x -= 0.5;
                }

                this.leftHindLeg.resolve(leftHindAnchor, midNormal);
                this.rightHindLeg.resolve(rightHindAnchor, midNormal);
            }

            display() {
                this.drawHindLegs();
                this.drawBody();
                this.drawHead();
                this.drawFrontLegs();
            }

            drawCurve(points, close = false) {
                // Draw a smooth curve through the points
                if (points.length < 2) return;
                
                ctx.beginPath();
                
                // Create tension for the curve
                const tension = 0.5;
                
                // Draw beginning
                ctx.moveTo(points[0].x, points[0].y);
                
                // Use bezier curves to approximate cardinal spline
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = i > 0 ? points[i - 1] : points[0];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = i < points.length - 2 ? points[i + 2] : p2;
                    
                    // Calculate control points
                    const cp1x = p1.x + (p2.x - p0.x) * tension / 3;
                    const cp1y = p1.y + (p2.y - p0.y) * tension / 3;
                    const cp2x = p2.x - (p3.x - p1.x) * tension / 3;
                    const cp2y = p2.y - (p3.y - p1.y) * tension / 3;
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                }
                
                if (close) {
                    ctx.closePath();
                }
            }

            drawBody() {
                const points = this.blob.points.map(p => p.pos);
                
                // Create smooth closing for the curve
                const allPoints = [
                    points[points.length - 2],
                    points[points.length - 1],
                    ...points,
                    points[0],
                    points[1]
                ];
                
                ctx.lineWidth = 8;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(allPoints, true);
                ctx.fill();
                ctx.stroke();
            }

            drawHead() {
                const top = this.blob.points[0].pos;
                const topNormal = Vector2.sub(
                    this.blob.points[2].pos, 
                    this.blob.points[this.blob.points.length - 2].pos
                ).heading();

                ctx.save();
                ctx.translate(top.x, top.y);
                ctx.rotate(topNormal);

                // Head
                ctx.beginPath();
                ctx.arc(0, 75, 250/2, -PI, 0, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(0, 75, 244/2, 219/2, 0, 0, TWO_PI);
                ctx.fillStyle = 'rgb(85, 145, 127)';
                ctx.fill();

                // Eye socket thingies
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'black';
                
                ctx.beginPath();
                ctx.arc(-75, -10, 75/2, -PI-PI/4.6, -PI/5.6, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(75, -10, 75/2, -PI+PI/5.6, PI/4.6, false);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(-75, -10, 70/2, 70/2, 0, 0, TWO_PI);
                ctx.fillStyle = 'rgb(85, 145, 127)';
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(75, -10, 70/2, 70/2, 0, 0, TWO_PI);
                ctx.fill();

                // Eyes
                ctx.lineWidth = 4;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(240, 153, 91)';
                
                // Animated eyes - apply open factor to size
                ctx.beginPath();
                ctx.ellipse(-75, -10, 48/2, 48/2 * leftEyeOpen, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                
                ctx.beginPath();
                ctx.ellipse(75, -10, 48/2, 48/2 * rightEyeOpen, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();

                // Pupils - only show when eyes are open enough
                if (leftEyeOpen > 0.5) {
                    // Scale pupil height with eye openness
                    const leftPupilHeight = 18/2 * Math.min(1, leftEyeOpen * 1.5);
                    
                    ctx.fillStyle = 'black';
                    ctx.save();
                    ctx.translate(-75, -10);
                    ctx.rotate(-PI/24);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 32/2, leftPupilHeight, 0, 0, TWO_PI);
                    ctx.fill();
                    ctx.restore();
                }
                
                if (rightEyeOpen > 0.5) {
                    // Scale pupil height with eye openness
                    const rightPupilHeight = 18/2 * Math.min(1, rightEyeOpen * 1.5);
                    
                    ctx.fillStyle = 'black';
                    ctx.save();
                    ctx.translate(75, -10);
                    ctx.rotate(PI/24);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 32/2, rightPupilHeight, 0, 0, TWO_PI);
                    ctx.fill();
                    ctx.restore();
                }

                // Throat/Chin - animate bulging during croaking
                ctx.lineWidth = 7;
                ctx.strokeStyle = 'black';
                
                const throatBulgeY = 10 * throatExpansion;
                const throatBulgeRadius = 92/2 * (1 + 0.2 * throatExpansion);
                
                ctx.beginPath();
                ctx.arc(0, 80 + throatBulgeY, throatBulgeRadius, PI/8, PI-PI/8, false);
                ctx.stroke();

                // Mouth - animate opening during croaking
                ctx.lineWidth = 5;
                ctx.beginPath();
                
                // Calculate control points for mouth animation
                const mouthOpenY = 15 * mouthOpenness;
                
                ctx.moveTo(-90, 40);
                ctx.bezierCurveTo(
                    -45, 60, 
                    -35, 15 - mouthOpenY, // Top curve control point 1
                    -10, 25 - mouthOpenY  // Top curve control point 2
                );
                ctx.bezierCurveTo(
                    -5, 27 - mouthOpenY,  // Center top
                    5, 27 - mouthOpenY,   // Center top
                    10, 25 - mouthOpenY   // Top curve control point 3
                );
                ctx.bezierCurveTo(
                    35, 15 - mouthOpenY,  // Top curve control point 4
                    45, 60, 
                    90, 40
                );
                ctx.stroke();
                
                // Add bottom lip/inside of mouth when open
                if (mouthOpenness > 0.1) {
                    ctx.beginPath();
                    
                    // Draw mouth interior with depth based on openness
                    const mouthDepth = 8 * mouthOpenness;
                    
                    ctx.moveTo(-60, 40);
                    ctx.bezierCurveTo(
                        -30, 45 + mouthDepth, 
                        -15, 30 + mouthDepth,
                        0, 32 + mouthDepth
                    );
                    ctx.bezierCurveTo(
                        15, 30 + mouthDepth,
                        30, 45 + mouthDepth,
                        60, 40
                    );
                    
                    // Draw mouth interior
                    ctx.fillStyle = `rgba(150, 30, 30, ${mouthOpenness * 0.8})`;
                    ctx.fill();
                    ctx.stroke();
                }

                // Nostrils
                ctx.fillStyle = 'black';
                
                // Left nostril
                ctx.save();
                ctx.translate(-9, 5);
                ctx.rotate(PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 0, 2/2, 5/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Right nostril
                ctx.save();
                ctx.translate(9, 5);
                ctx.rotate(-PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 0, 2/2, 5/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }

            drawFrontLegs() {
                const left = this.blob.points[12].pos;
                const right = this.blob.points[4].pos;
                const leftAnchor = Vector2.lerp(left, right, 0.25).add(new Vector2(0, 10));
                const rightAnchor = Vector2.lerp(left, right, 0.75).add(new Vector2(0, 10));
                this.drawFrontLeg(leftAnchor, this.leftFrontLeg);
                this.drawFrontLeg(rightAnchor, this.rightFrontLeg);
            }

            drawHindLegs() {
                const left = this.blob.points[12].pos;
                const right = this.blob.points[4].pos;
                const midSecant = Vector2.sub(right, left).setMag(64);
                const leftAnchor = Vector2.add(this.blob.points[11].pos, midSecant).add(new Vector2(0, 16));
                const rightAnchor = Vector2.sub(this.blob.points[5].pos, midSecant).add(new Vector2(0, 16));
                this.drawHindLeg(leftAnchor, this.leftHindLeg, false);
                this.drawHindLeg(rightAnchor, this.rightHindLeg, true);
            }

            drawFrontLeg(anchor, limb) {
                // Draw the outline
                ctx.lineWidth = 48;
                ctx.strokeStyle = 'black';
                
                const curvePoints = [
                    anchor,
                    anchor,
                    limb.elbow.pos,
                    limb.foot.pos,
                    limb.foot.pos
                ];
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw the fill
                ctx.lineWidth = 34;
                ctx.strokeStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw toes
                const footNormal = Vector2.sub(limb.elbow.pos, limb.foot.pos).heading() + HALF_PI;
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.save();
                ctx.translate(limb.foot.pos.x, limb.foot.pos.y);
                
                // First toe
                ctx.save();
                ctx.rotate(footNormal - PI/4);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Second toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Third toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Fourth toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 3*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Hide overlaps
                ctx.strokeStyle = 'transparent';
                
                // First overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Second overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Third overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4);
                ctx.beginPath();
                ctx.ellipse(0, 16, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                ctx.restore();

                // Hide limb-body connection
                const shoulderNormal = Vector2.sub(anchor, limb.elbow.pos).heading();
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.beginPath();
                ctx.arc(anchor.x, anchor.y, 49/2, -HALF_PI+shoulderNormal, HALF_PI+shoulderNormal);
                ctx.fill();

                // Hide toe-foot connection
                ctx.beginPath();
                ctx.ellipse(limb.foot.pos.x, limb.foot.pos.y, 35/2, 35/2, 0, 0, TWO_PI);
                ctx.fill();
            }

            drawHindLeg(anchor, limb, right) {
                const offset = right ? -PI/8 : PI/8;
                const footNormal = Vector2.sub(limb.elbow.pos, limb.foot.pos).heading() + HALF_PI + offset;
                const footShift = Vector2.add(limb.foot.pos, Vector2.fromAngle(footNormal + HALF_PI).setMag(24));
                
                // Draw the outline
                ctx.lineWidth = 48;
                ctx.strokeStyle = 'black';
                
                const curvePoints = [
                    anchor, 
                    anchor, 
                    limb.elbow.pos, 
                    limb.foot.pos, 
                    footShift, 
                    footShift
                ];
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw the fill
                ctx.lineWidth = 34;
                ctx.strokeStyle = 'rgb(85, 145, 127)';
                
                this.drawCurve(curvePoints);
                ctx.stroke();

                // Draw toes
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.save();
                ctx.translate(footShift.x, footShift.y);
                
                // First toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Second toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Third toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Fourth toe
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 3*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 16, 16/2, 55/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // Hide overlaps
                ctx.strokeStyle = 'transparent';
                
                // First overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + 2*PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Second overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset + PI/6);
                ctx.beginPath();
                ctx.ellipse(0, 28, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                // Third overlap cover
                ctx.save();
                ctx.rotate(footNormal - PI/4 + offset);
                ctx.beginPath();
                ctx.ellipse(0, 16, 10/2, 49/2, 0, 0, TWO_PI);
                ctx.fill();
                ctx.restore();
                
                ctx.restore();

                // Hide limb-body connection
                const shoulderNormal = Vector2.sub(anchor, limb.elbow.pos).heading();
                ctx.fillStyle = 'rgb(85, 145, 127)';
                
                ctx.beginPath();
                ctx.arc(anchor.x, anchor.y, 49/2, -HALF_PI+shoulderNormal, HALF_PI+shoulderNormal);
                ctx.fill();

                // Hide toe-foot connection
                ctx.beginPath();
                ctx.ellipse(footShift.x, footShift.y, 35/2, 35/2, 0, 0, TWO_PI);
                ctx.fill();
            }
        }

        // Initialize the application
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Make canvas fullscreen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize mouse position tracking
            mouseX = canvas.width / 2;
            mouseY = canvas.height / 2;
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            mouseSpeed = 0;
            
            // Create the frog
            frog = new Frog(new Vector2(canvas.width / 2, canvas.height - 400));
            
            // Load all sound elements
            croakSound = document.getElementById('croak-sound');
            wednesdaySound = document.getElementById('wednesday-sound');
            screamSound = document.getElementById('scream-sound');
            
            // Set Wednesday mode based on override or actual day
            if (WEDNESDAY_ENABLED) {
                // Check if it's actually Wednesday or if override is enabled
                const today = new Date().getDay();
                isWednesday = WEDNESDAY_OVERRIDE || today === 3; // 3 is Wednesday (0 is Sunday)
                
                if (isWednesday && DEBUG_AUDIO) {
                    console.log("Wednesday mode activated!");
                }
                
                // Show Wednesday text if it's Wednesday
                if (isWednesday) {
                    document.getElementById('wednesday-text').style.display = 'block';
                }
            }
            
            // Generate speech keyframes for Wednesday mode
            if (isWednesday) {
                generateWednesdaySpeechKeyframes();
            }
            
            // Detect if user is on mobile
            isMobile = isMobileDevice();
            
            // Add mouse event listeners for desktop
            canvas.addEventListener('mousemove', (e) => {
                // Only use mouse events if not on mobile
                if (isMobile) return;
                
                // Calculate mouse speed
                const dx = e.clientX - prevMouseX;
                const dy = e.clientY - prevMouseY;
                mouseSpeed = Math.sqrt(dx*dx + dy*dy);
                
                // Update positions
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Check for fast movement and trigger scream
                if (mousePressed) {
                    checkForScreamDesktop(mouseSpeed);
                }
            });
            
            canvas.addEventListener('mousedown', (e) => {
                // Only use mouse events if not on mobile
                if (isMobile) return;
                
                mousePressed = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Slight chance of croaking when clicked
                if (Math.random() < CLICK_CROAK_CHANCE && !croakInProgress) {
                    startCroaking();
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                // Only use mouse events if not on mobile
                if (isMobile) return;
                
                mousePressed = false;
            });
            
            // Add touch event listeners for mobile
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    
                    // Record the start position and time
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    touchMoveX = touchStartX;
                    touchMoveY = touchStartY;
                    touchDragStartTime = performance.now();
                    touchActive = true;
                    
                    // Set mouse position for the frog physics
                    mouseX = touchStartX;
                    mouseY = touchStartY;
                    prevMouseX = mouseX;
                    prevMouseY = mouseY;
                    mousePressed = true;
                    
                    // Reset tracking
                    touchDragDistance = 0;
                    touchDragSpeed = 0;
                    
                    // Slight chance of croaking when touched
                    if (Math.random() < CLICK_CROAK_CHANCE && !croakInProgress) {
                        startCroaking();
                    }
                }
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                
                if (e.touches.length > 0 && touchActive) {
                    const touch = e.touches[0];
                    const currentTime = performance.now();
                    
                    // Calculate drag distance and speed
                    const dx = touch.clientX - touchMoveX;
                    const dy = touch.clientY - touchMoveY;
                    const moveDistance = Math.sqrt(dx*dx + dy*dy);
                    
                    // Calculate instantaneous speed
                    const timeDelta = currentTime - lastTouchMoveTime;
                    if (timeDelta > 0) {
                        touchDragSpeed = moveDistance / (timeDelta / 1000); // pixels per second
                    }
                    
                    // Update total drag distance
                    touchDragDistance += moveDistance;
                    
                    // Update positions for next frame
                    touchMoveX = touch.clientX;
                    touchMoveY = touch.clientY;
                    lastTouchMoveTime = currentTime;
                    
                    // Update mouse position for the frog physics
                    prevMouseX = mouseX;
                    prevMouseY = mouseY;
                    mouseX = touchMoveX;
                    mouseY = touchMoveY;
                    mousePressed = true;
                    
                    // Use adjusted speed for mobile
                    mouseSpeed = touchDragSpeed / 15; // Scale down to match mouse scale
                    
                    // Check for fast movement to trigger scream
                    checkForScreamMobile(touchDragSpeed);
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                if (touchActive) {
                    touchActive = false;
                    mousePressed = false;
                    
                    // Calculate final throw speed and direction
                    const touchDuration = performance.now() - touchDragStartTime;
                    const throwSpeed = touchDragSpeed;
                    
                    if (DEBUG_AUDIO) {
                        console.log(`Touch ended - Duration: ${touchDuration.toFixed(0)}ms, Speed: ${throwSpeed.toFixed(2)}px/s, Distance: ${touchDragDistance.toFixed(2)}px`);
                    }
                    
                    // Special check for throw gesture on touchend
                    // This is the most important part for mobile - detect a throw when finger is released
                    if (throwSpeed > TOUCH_SPEED_THRESHOLD * TOUCH_THROW_SENSITIVITY && touchDragDistance > 50) {
                        if (DEBUG_AUDIO) {
                            console.log(`THROW DETECTED! Speed: ${throwSpeed.toFixed(2)}`);
                        }
                        checkForScreamMobile(throwSpeed, true);
                    }
                }
            });
            
            canvas.addEventListener('touchcancel', () => {
                mousePressed = false;
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                frog = new Frog(new Vector2(canvas.width / 2, canvas.height - 400));
            });
            
            // Add motion toggle button event listener
            document.getElementById('motion-btn').addEventListener('click', toggleDeviceMotion);
            
            // Set up initial croak delay (between 5-15 seconds)
            nextCroakDelay = Math.random() * 10000 + 5000;
            
            // Start animation loop
            requestAnimationFrame(animate);
        }
        
        // Function to unlock audio - can only be called after user interaction
        function unlockAudio() {
            // Play silent audio to unlock audio context
            const silentAudio = document.getElementById('silent-audio');
            
            // Try to play all audio elements to unlock them
            try {
                silentAudio.play().catch(err => console.log('Silent audio unlock failed, but that\'s okay'));
                croakSound.play().then(() => croakSound.pause()).catch(err => {});
                wednesdaySound.play().then(() => wednesdaySound.pause()).catch(err => {});
                screamSound.play().then(() => screamSound.pause()).catch(err => {});
                
                if (DEBUG_AUDIO) {
                    console.log('Audio unlocked!');
                }
            } catch(e) {
                console.log('Error unlocking audio:', e);
            }
        }

        // Function to check for screams on desktop
        function checkForScreamDesktop(mouseSpeed) {
            const currentTime = performance.now();
            
            // Calculate frog movement
            let frogMovementAmount = calculateFrogMovement();
            
            // Only scream if:
            // 1. Screaming is enabled
            // 2. Speed exceeds threshold
            // 3. The frog is actually moving (not just the mouse)
            // 4. We're not already croaking
            // 5. We're past the cooldown period
            if (SCREAM_ENABLED && 
                mouseSpeed > MOUSE_SPEED_THRESHOLD && 
                frogMovementAmount > FROG_MOVEMENT_THRESHOLD && 
                !croakInProgress && 
                currentTime - lastScreamTime > SCREAM_COOLDOWN) {
                
                // Play the scream
                playScream();
                
                // Update last scream time for cooldown
                lastScreamTime = currentTime;
                
                if (DEBUG_AUDIO) {
                    console.log(`DESKTOP SCREAM! Speed: ${mouseSpeed.toFixed(2)}, Frog movement: ${frogMovementAmount.toFixed(2)}`);
                }
            }
        }
        
        // Function to check for screams on mobile
        function checkForScreamMobile(touchSpeed, isThrow = false) {
            const currentTime = performance.now();
            
            // Calculate frog movement
            let frogMovementAmount = calculateFrogMovement();
            
            // For mobile, we're more generous with the throw detection
            const speedThreshold = isThrow ? 
                TOUCH_SPEED_THRESHOLD : // Lower threshold for throws
                TOUCH_SPEED_THRESHOLD * 2; // Higher threshold for general movement
            
            // Lower movement threshold for mobile
            const movementThreshold = isThrow ? 
                FROG_MOVEMENT_THRESHOLD / 1.5 : // Lower threshold for throws
                FROG_MOVEMENT_THRESHOLD; // Normal threshold otherwise
            
            // Only scream if:
            // 1. Screaming is enabled
            // 2. Speed exceeds threshold
            // 3. The frog is actually moving
            // 4. We're not already croaking
            // 5. We're past the cooldown period
            if (SCREAM_ENABLED && 
                touchSpeed > speedThreshold && 
                frogMovementAmount > movementThreshold && 
                !croakInProgress && 
                currentTime - lastScreamTime > SCREAM_COOLDOWN) {
                
                // Play the scream
                playScream();
                
                // Update last scream time for cooldown
                lastScreamTime = currentTime;
                
                if (DEBUG_AUDIO) {
                    console.log(`MOBILE ${isThrow ? 'THROW' : 'DRAG'} SCREAM! Speed: ${touchSpeed.toFixed(2)}, Frog movement: ${frogMovementAmount.toFixed(2)}`);
                }
            }
        }
        
        // Calculate how much the frog is actually moving
        function calculateFrogMovement() {
            let frogMovementAmount = 0;
            if (frog && frog.blob && frog.blob.points) {
                // Sample a few blob points and calculate their average movement
                let totalMovement = 0;
                let sampledPoints = 0;
                
                // Sample head, back, and legs areas (points 0, 4, 8, 12)
                const keyPointIndices = [0, 4, 8, 12];
                for (const index of keyPointIndices) {
                    if (frog.blob.points[index]) {
                        const point = frog.blob.points[index];
                        const pointSpeed = Vector2.dist(point.pos, point.ppos);
                        totalMovement += pointSpeed;
                        sampledPoints++;
                    }
                }
                
                if (sampledPoints > 0) {
                    frogMovementAmount = totalMovement / sampledPoints;
                }
            }
            return frogMovementAmount;
        }
        
        // Add a function to check for motion-induced screams
        function checkForScreamMotion() {
            // Only check if motion controls are active and gravity changed recently
            if (!useDeviceMotion || gravityChangeSpeed < GRAVITY_CHANGE_THRESHOLD) {
                return;
            }
            
            const currentTime = performance.now();
            
            // Calculate frog movement
            let frogMovementAmount = calculateFrogMovement();
            
            // Special handling for motion-induced movement
            // The thresholds are lower because this is passive movement
            if (SCREAM_ENABLED && 
                frogMovementAmount > FROG_MOVEMENT_THRESHOLD * 0.8 && 
                !croakInProgress && 
                currentTime - lastScreamTime > SCREAM_COOLDOWN) {
                
                // Play the scream
                playScream();
                
                // Update last scream time for cooldown
                lastScreamTime = currentTime;
                
                if (DEBUG_AUDIO) {
                    console.log(`MOTION SCREAM! Gravity change: ${gravityChangeSpeed.toFixed(2)}, Frog movement: ${frogMovementAmount.toFixed(2)}`);
                }
            }
        }

        // Device motion functions
        function requestDeviceMotionPermission() {
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ requires explicit permission
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            enableDeviceMotion();
                        }
                    })
                    .catch(console.error);
            } else {
                // Other devices don't need permission
                enableDeviceMotion();
            }
        }

        function enableDeviceMotion() {
            useDeviceMotion = true;
            window.addEventListener('deviceorientation', handleOrientation);
            window.addEventListener('devicemotion', handleMotion);
            
            // Update UI
            const motionBtn = document.getElementById('motion-btn');
            motionBtn.innerText = 'Disable Motion Controls';
            
            // Reset tracked values
            prevGravitySensor = {x: 0, y: 1};
            gravitySensor = {x: 0, y: 1};
            gravityChangeSpeed = 0;
            lastGravityCheckTime = performance.now();
            
            if (DEBUG_AUDIO) {
                console.log("Motion controls enabled");
            }
        }

        function disableDeviceMotion() {
            useDeviceMotion = false;
            window.removeEventListener('deviceorientation', handleOrientation);
            window.removeEventListener('devicemotion', handleMotion);
            
            // Reset gravity to default (down)
            gravitySensor = { x: 0, y: 1 };
            
            // Update UI
            const motionBtn = document.getElementById('motion-btn');
            motionBtn.innerText = 'Enable Motion Controls';
        }

        function toggleDeviceMotion() {
            if (useDeviceMotion) {
                disableDeviceMotion();
            } else {
                requestDeviceMotionPermission();
            }
        }

        function handleOrientation(event) {
            if (!useDeviceMotion) return;
            
            // Save previous gravity values
            prevGravitySensor.x = gravitySensor.x;
            prevGravitySensor.y = gravitySensor.y;
            
            // Get orientation angles in degrees
            const beta = event.beta;  // -180 to 180 (front-to-back tilt)
            const gamma = event.gamma; // -90 to 90 (left-to-right tilt)
            
            // Convert to gravity vector with appropriate scaling
            gravitySensor.x = Math.sin(gamma * Math.PI / 180) * 1.5;
            gravitySensor.y = Math.sin(beta * Math.PI / 180) * 1.5;
            
            // Ensure minimum gravity for better physics
            if (Math.abs(gravitySensor.y) < 0.3) gravitySensor.y = 0.3 * Math.sign(gravitySensor.y);
            
            // Check for rapid gravity changes that might trigger a scream
            checkGravityChanges();
        }

        function handleMotion(event) {
            if (!useDeviceMotion) return;
            
            // Save previous gravity values
            prevGravitySensor.x = gravitySensor.x;
            prevGravitySensor.y = gravitySensor.y;
            
            // Get acceleration including gravity
            const accel = event.accelerationIncludingGravity;
            
            // Use acceleration if available (fallback to orientation-based gravity)
            if (accel && accel.x !== null && accel.y !== null) {
                // Scale acceleration for better physics feel
                gravitySensor.x = accel.x * 0.1;
                gravitySensor.y = accel.y * 0.1;
                
                // Ensure minimum gravity
                if (Math.abs(gravitySensor.y) < 0.3) gravitySensor.y = 0.3 * Math.sign(gravitySensor.y);
            }
            
            // Check for rapid gravity changes that might trigger a scream
            checkGravityChanges();
        }
        
        // Function to detect rapid changes in gravity and trigger screams
        function checkGravityChanges() {
            const currentTime = performance.now();
            
            // Only check periodically to avoid too frequent checks
            if (currentTime - lastGravityCheckTime < GRAVITY_CHECK_INTERVAL) {
                return;
            }
            
            // Calculate how much gravity changed
            const dx = gravitySensor.x - prevGravitySensor.x;
            const dy = gravitySensor.y - prevGravitySensor.y;
            const gravityChange = Math.sqrt(dx*dx + dy*dy);
            
            // Save the change speed for animation frame to use
            gravityChangeSpeed = gravityChange / (GRAVITY_CHECK_INTERVAL / 1000);
            
            lastGravityCheckTime = currentTime;
            
            // If gravity changed rapidly, we'll check for scream in the next animation frame
            // This is done in animate() to ensure we measure actual frog movement after gravity change
        }

        // Animation loop
        function animate() {
            // Clear canvas
            ctx.fillStyle = 'rgb(40, 44, 52)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update animations
            updateEyeAnimation();
            updateCroakAnimation();
            
            // Update and display frog
            frog.update();
            frog.display();
            
            // Check for motion-induced screams
            checkForScreamMotion();
            
            // Continue animation
            requestAnimationFrame(animate);
        }
        
        // Handle eye blinking animation
        function updateEyeAnimation() {
            const currentTime = performance.now();
            const timeSinceLastBlink = currentTime - lastBlinkTime;
            
            // Start a new blink if enough time has passed
            if (!blinkInProgress && timeSinceLastBlink > nextBlinkDelay) {
                blinkInProgress = true;
                
                // Decide if both eyes blink together or separately with a delay
                const syncedBlink = Math.random() < 0.7; // 70% chance of synchronized blink
                
                if (syncedBlink) {
                    // Synchronized blink
                    animateEyeBlink(true, true, 0);
                } else {
                    // Staggered blink
                    const leftFirst = Math.random() < 0.5;
                    if (leftFirst) {
                        animateEyeBlink(true, false, 0);
                        setTimeout(() => animateEyeBlink(false, true, 0), Math.random() * 150 + 50);
                    } else {
                        animateEyeBlink(false, true, 0);
                        setTimeout(() => animateEyeBlink(true, false, 0), Math.random() * 150 + 50);
                    }
                }
                
                // Set up next blink
                lastBlinkTime = currentTime;
                // Random delay between min and max blink delay
                nextBlinkDelay = Math.random() * (MAX_BLINK_DELAY - MIN_BLINK_DELAY) + MIN_BLINK_DELAY;
                
                // Sometimes add an extra rapid blink (like the frog is confused)
                if (Math.random() < 0.2) { // 20% chance
                    setTimeout(() => {
                        animateEyeBlink(true, true, 0);
                        setTimeout(() => {
                            blinkInProgress = false;
                        }, 300);
                    }, 300);
                } else {
                    // Mark blink as complete after the animation finishes
                    setTimeout(() => {
                        blinkInProgress = false;
                    }, 300);
                }
            }
        }
        
        // Animate a single eye blink
        function animateEyeBlink(blinkLeft, blinkRight, progress) {
            // Blink animation duration in milliseconds
            const blinkDuration = 300;
            const step = 10; // ms per step
            
            // Ease-in-out curve for natural blinking
            let easedProgress;
            if (progress < 0.5) {
                // Closing phase (ease-in)
                easedProgress = 2 * progress * progress;
            } else {
                // Opening phase (ease-out)
                const t = 2 * progress - 1;
                easedProgress = 1 - (1 - t) * (1 - t) / 2;
            }
            
            // Update eye openness
            if (blinkLeft) {
                // Map progress 0-1 to eye openness 1-0-1 (open-closed-open)
                leftEyeOpen = progress < 0.5 ? 
                    1 - 2 * easedProgress : // 1 to 0 (closing)
                    (progress - 0.5) * 2;   // 0 to 1 (opening)
            }
            
            if (blinkRight) {
                // Map progress 0-1 to eye openness 1-0-1 (open-closed-open)
                rightEyeOpen = progress < 0.5 ? 
                    1 - 2 * easedProgress : // 1 to 0 (closing)
                    (progress - 0.5) * 2;   // 0 to 1 (opening)
            }
            
            // Continue animation if not complete
            if (progress < 1) {
                setTimeout(() => {
                    animateEyeBlink(blinkLeft, blinkRight, progress + step/blinkDuration);
                }, step);
            } else {
                // Ensure eyes are fully open when animation completes
                if (blinkLeft) leftEyeOpen = 1;
                if (blinkRight) rightEyeOpen = 1;
            }
        }
        
        // Generate keyframes for Wednesday speech
        function generateWednesdaySpeechKeyframes() {
            // Approximate mouth shapes for "It is Wednesday my dudes"
            // Format: [startTime, endTime, mouthOpenness, throatExpansion]
            speechKeyframes = [
                [0.1, 0.2, 0.4, 0.1],  // "I"
                [0.3, 0.45, 0.3, 0.2],  // "t"
                [0.5, 0.7, 0.6, 0.3],  // "is"
                [0.8, 1.0, 0.7, 0.5],  // "Wed"
                [1.0, 1.2, 0.5, 0.4],  // "nes"
                [1.2, 1.4, 0.6, 0.3],  // "day"
                [1.5, 1.7, 0.4, 0.2],  // "my"
                [1.8, 2.3, 0.9, 0.8]   // "duuudes"
            ];
        }
        
        // Handle croaking animation and sound
        function updateCroakAnimation() {
            const currentTime = performance.now();
            const timeSinceLastCroak = currentTime - lastCroakTime;
            
            // Start a new croak if enough time has passed
            if (!croakInProgress && timeSinceLastCroak > nextCroakDelay) {
                startCroaking();
                
                // Set up next croak with random delay between min and max
                lastCroakTime = currentTime;
                nextCroakDelay = Math.random() * (MAX_CROAK_DELAY - MIN_CROAK_DELAY) + MIN_CROAK_DELAY;
            }
        }
        
        // Start the croaking animation and sound
        function startCroaking() {
            croakInProgress = true;
            
            if (DEBUG_AUDIO) {
                console.log("Starting to croak");
                console.log("Is Wednesday mode?", isWednesday);
            }
            
            // Play the appropriate sound based on day
            if (isWednesday) {
                if (DEBUG_AUDIO) console.log("Using Wednesday sound");
                playWednesdaySound();
            } else {
                if (DEBUG_AUDIO) console.log("Using normal ribbit sound");
                playRibbitSound();
            }
        }
        
        // Play regular ribbit sound with matching animation
        function playRibbitSound() {
            try {
                // Reset sound to beginning if it's already playing
                croakSound.currentTime = 0;
                
                // Play the sound immediately and get its duration
                croakSound.play().then(() => {
                    // Get actual audio duration
                    const audioDuration = croakSound.duration;
                    
                    // Add listeners to sync with audio
                    croakSound.ontimeupdate = updateRibbitAnimation;
                    
                    // Handle animation end
                    croakSound.onended = () => {
                        mouthOpenness = 0;
                        throatExpansion = 0;
                        croakInProgress = false;
                        croakSound.ontimeupdate = null;
                    };
                    
                }).catch(err => {
                    console.log('Audio not allowed without user interaction');
                    // If audio fails, fall back to timed animation
                    animateRibbit(0);
                });
                
            } catch (e) {
                console.log('Error playing sound:', e);
                // Fall back to timed animation
                animateRibbit(0);
                
                // Set a timeout to end the animation
                setTimeout(() => {
                    croakInProgress = false;
                }, 800);
            }
        }
        
        // Update mouth animation to match ribbit audio
        function updateRibbitAnimation() {
            const currentTime = croakSound.currentTime;
            const duration = croakSound.duration;
            
            // Calculate a normalized position in the sound (0 to 1)
            const progress = currentTime / duration;
            
            // These key points should be adjusted based on your specific ribbit sound file
            if (progress < 0.1) {
                // Initial mouth opening
                mouthOpenness = progress * 10 * 0.8; // Ramp up to 80% open
                throatExpansion = progress * 10 * 0.9; // Ramp up to 90% expanded
            } 
            else if (progress < 0.4) {
                // Main ribbit sound - mouth fully open
                mouthOpenness = 0.8;
                throatExpansion = 0.9 + Math.sin(progress * 30) * 0.1; // Slight pulsing
            }
            else if (progress < 0.7) {
                // Start closing
                const closeProgress = (progress - 0.4) / 0.3; // 0 to 1
                mouthOpenness = 0.8 * (1 - closeProgress);
                throatExpansion = 0.9 * (1 - closeProgress * 0.5); // Throat closes more slowly
            }
            else {
                // Final closing
                const closeProgress = (progress - 0.7) / 0.3; // 0 to 1
                mouthOpenness = 0.8 * 0.3 * (1 - closeProgress);
                throatExpansion = 0.9 * 0.5 * (1 - closeProgress);
            }
            
            // Apply easing for more natural movement
            mouthOpenness = Math.sin(mouthOpenness * Math.PI/2);
            throatExpansion = Math.sin(throatExpansion * Math.PI/2);
        }
        
        // Play Wednesday sound with synced mouth animation
        function playWednesdaySound() {
            try {
                // Reset and play Wednesday sound
                wednesdaySound.currentTime = 0;
                
                // Set up animation to sync with audio
                currentSpeechKeyframe = 0;
                
                // Play audio
                wednesdaySound.play().then(() => {
                    // Animation will be driven by audio timeupdate event
                    animateWednesdaySpeech();
                }).catch(err => {
                    console.log('Audio not allowed without user interaction:', err);
                    // If audio fails, end the animation
                    croakInProgress = false;
                });
                
                // Set up timeupdate listener to sync animation with audio
                wednesdaySound.ontimeupdate = updateWednesdaySpeechAnimation;
                
                // Handle animation end
                wednesdaySound.onended = () => {
                    mouthOpenness = 0;
                    throatExpansion = 0;
                    croakInProgress = false;
                    wednesdaySound.ontimeupdate = null;
                };
                
            } catch (e) {
                console.log('Error playing Wednesday sound:', e);
                croakInProgress = false;
            }
        }
        
        // Play scream sound with matching animation 
        function playScream() {
            croakInProgress = true;
            
            try {
                // Reset and play scream sound
                screamSound.currentTime = 0;
                
                // Play the sound and set up animation
                screamSound.play().then(() => {
                    // Get actual audio duration
                    const audioDuration = screamSound.duration;
                    
                    // Add listeners to sync with audio
                    screamSound.ontimeupdate = updateScreamAnimation;
                    
                    // Handle animation end
                    screamSound.onended = () => {
                        mouthOpenness = 0;
                        throatExpansion = 0;
                        croakInProgress = false;
                        screamSound.ontimeupdate = null;
                        
                        if (DEBUG_AUDIO) {
                            console.log("Scream sound ended");
                        }
                    };
                    
                }).catch(err => {
                    console.log('Audio not allowed without user interaction:', err);
                    // If audio fails, fall back to timed animation
                    animateScream(0);
                });
                
            } catch (e) {
                console.log('Error playing scream sound:', e);
                // Fall back to timed animation
                animateScream(0);
                
                // Set a timeout to end the animation
                setTimeout(() => {
                    croakInProgress = false;
                }, 2500); // Longer duration to ensure sound completes
            }
        }
        
        // Update scream animation to match audio playback
        function updateScreamAnimation() {
            const currentTime = screamSound.currentTime;
            const duration = screamSound.duration;
            
            // Calculate a normalized position in the sound (0 to 1)
            const progress = currentTime / duration;
            
            // Based on typical scream sound pattern
            if (progress < 0.05) {
                // Quick opening phase
                mouthOpenness = progress * 20; // Ramp up to fully open quickly
                throatExpansion = progress * 20 * 1.2; // Expand throat even more
            } 
            else if (progress < 0.85) {
                // Keep wide open for most of the scream
                mouthOpenness = 1.0;
                // Add wobble for effect
                throatExpansion = 1.2 + Math.sin(progress * 50) * 0.15;
            }
            else {
                // Only start closing near the very end
                const closeProgress = (progress - 0.85) / 0.15; // 0 to 1
                mouthOpenness = 1.0 * (1 - closeProgress);
                throatExpansion = 1.2 * (1 - closeProgress);
            }
            
            // Apply easing for more natural movement
            mouthOpenness = Math.sin(mouthOpenness * Math.PI/2);
            throatExpansion = Math.sin(throatExpansion * Math.PI/2);
        }
        
        // Update mouth animation to match Wednesday speech audio position
        function updateWednesdaySpeechAnimation() {
            const currentTime = wednesdaySound.currentTime;
            
            // Find the appropriate keyframe for the current time
            for (let i = 0; i < speechKeyframes.length; i++) {
                const [startTime, endTime, mouthOpen, throatExpand] = speechKeyframes[i];
                
                if (currentTime >= startTime && currentTime <= endTime) {
                    // We're in this keyframe
                    const progress = (currentTime - startTime) / (endTime - startTime);
                    
                    // First half: opening mouth/throat
                    // Second half: closing mouth/throat
                    let openFactor;
                    if (progress < 0.5) {
                        openFactor = progress * 2; // 0 to 1
                    } else {
                        openFactor = 2 - (progress * 2); // 1 to 0
                    }
                    
                    // Apply easing for natural movement
                    openFactor = Math.sin(openFactor * Math.PI/2);
                    
                    // Set mouth and throat values
                    mouthOpenness = mouthOpen * openFactor;
                    throatExpansion = throatExpand * openFactor;
                    
                    return;
                }
            }
            
            // If we're not in any keyframe, keep mouth slightly open
            mouthOpenness = 0.1;
            throatExpansion = 0.1;
        }
        
        // Start the Wednesday speech animation 
        function animateWednesdaySpeech() {
            // Initialize animation state
            mouthOpenness = 0.1; // Start with slightly open mouth
            throatExpansion = 0.1;
            
            // Make sure the first keyframe is ready
            currentSpeechKeyframe = 0;
            
            // Add a slight initial mouth movement before speech begins
            setTimeout(() => {
                mouthOpenness = 0.2;
                throatExpansion = 0.2;
            }, 50);
            
            setTimeout(() => {
                mouthOpenness = 0.1;
                throatExpansion = 0.1;
            }, 100);
        }
        
        // Animate a normal ribbit at a specific progress point (0 to 1)
        function animateRibbit(progress) {
            // Total animation duration in milliseconds
            const duration = 800;
            const step = 10; // ms per step
            
            // Create a multi-phase animation for more natural croaking
            let mouthCurve, throatCurve;
            
            if (progress < 0.2) {
                // Opening phase
                mouthCurve = progress * 5; // 0 to 1 (quickly)
                throatCurve = progress * 5; // 0 to 1 (quickly)
            } else if (progress < 0.5) {
                // Hold open
                mouthCurve = 1;
                throatCurve = 1;
            } else if (progress < 0.8) {
                // Start closing
                mouthCurve = 1 - ((progress - 0.5) * (1/0.3)); // 1 to 0
                throatCurve = 1;
            } else {
                // Finish closing throat
                mouthCurve = 0;
                throatCurve = 1 - ((progress - 0.8) * (1/0.2)); // 1 to 0
            }
            
            // Apply easing for more natural movement
            mouthCurve = Math.sin(mouthCurve * Math.PI/2);
            throatCurve = Math.sin(throatCurve * Math.PI/2);
            
            // Update animation values
            mouthOpenness = mouthCurve * 0.8; // Maximum mouth openness for ribbit
            throatExpansion = throatCurve;
            
            // Continue animation if not complete
            if (progress < 1) {
                setTimeout(() => {
                    animateRibbit(progress + step/duration);
                }, step);
            } else {
                // Reset values and mark as complete
                mouthOpenness = 0;
                throatExpansion = 0;
                
                // Sometimes do a double croak
                if (Math.random() < DOUBLE_CROAK_CHANCE) {
                    setTimeout(() => {
                        animateRibbit(0);
                        
                        // Play sound again
                        setTimeout(() => {
                            try {
                                croakSound.currentTime = 0;
                                croakSound.play().catch(err => {});
                            } catch (e) {}
                        }, 150);
                        
                        // Mark croaking as complete after the second animation
                        setTimeout(() => {
                            croakInProgress = false;
                        }, 800);
                    }, 300); // Short pause between croaks
                } else {
                    // Mark croaking as complete
                    croakInProgress = false;
                }
            }
        }
        
        // Animate a scream - fallback if audio API fails
        function animateScream(progress) {
            // Total animation duration - longer to match most scream sounds
            const duration = 2500; // 2.5 seconds
            const step = 10; // ms per step
            
            // Create a sustained screaming animation
            let mouthCurve, throatCurve;
            
            if (progress < 0.05) {
                // Quick opening phase
                mouthCurve = progress * 20; // 0 to 1 (very quickly)
                throatCurve = progress * 20; // 0 to 1 (very quickly)
            } else if (progress < 0.85) {
                // Hold wide open for most of the animation
                mouthCurve = 1;
                throatCurve = 1;
                
                // Add some wobble for effect
                const wobble = Math.sin(progress * 50) * 0.1;
                mouthCurve += wobble;
                throatCurve += wobble;
            } else {
                // Closing phase only at end
                mouthCurve = 1 - ((progress - 0.85) / 0.15); // 1 to 0
                throatCurve = 1 - ((progress - 0.85) / 0.15); // 1 to 0
            }
            
            // Update animation values - make screaming extra wide
            mouthOpenness = mouthCurve;
            throatExpansion = throatCurve * 1.2; // Extra throat expansion for screaming
            
            // Continue animation if not complete
            if (progress < 1) {
                setTimeout(() => {
                    animateScream(progress + step/duration);
                }, step);
            } else {
                // Reset values and mark as complete
                mouthOpenness = 0;
                throatExpansion = 0;
                croakInProgress = false;
            }
        }

        // Start the application when page loads
        window.onload = function() {
            // Set up the splash screen first
            const splashScreen = document.getElementById('splash-screen');
            const startButton = document.getElementById('start-button');
            
            // When the start button is clicked
            startButton.addEventListener('click', function() {
                // Unlock audio first
                unlockAudio();
                
                // Hide splash screen with fade effect
                splashScreen.classList.add('hidden');
                
                // Initialize the application after a short delay
                setTimeout(function() {
                    init();
                }, 500);
            });
        };
        
        // Check if device is mobile or tablet
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
            return mobileRegex.test(userAgent) || 
                   (window.innerWidth <= 800 && window.innerHeight <= 900);
        }
        
        // Handle info panel minimizing/maximizing
        document.addEventListener('DOMContentLoaded', function() {
            const infoPanel = document.getElementById('info-panel');
            const minimizeBtn = document.getElementById('minimize-btn');
            const showInfoBtn = document.getElementById('show-info');
            const motionBtn = document.getElementById('motion-btn');
            
            minimizeBtn.addEventListener('click', function() {
                infoPanel.style.display = 'none';
                showInfoBtn.style.display = 'block';
            });
            
            showInfoBtn.addEventListener('click', function() {
                infoPanel.style.display = 'block';
                showInfoBtn.style.display = 'none';
            });
            
            // Auto-hide info panel after 10 seconds, but only on desktop
            if (window.innerWidth > 768) {
                setTimeout(function() {
                    infoPanel.style.opacity = '0.3';
                }, 5000);
                
                infoPanel.addEventListener('mouseenter', function() {
                    infoPanel.style.opacity = '1';
                });
                
                infoPanel.addEventListener('mouseleave', function() {
                    infoPanel.style.opacity = '0.3';
                });
            }
            
            // Only show motion controls on mobile devices
            if (isMobileDevice() && (window.DeviceMotionEvent || window.DeviceOrientationEvent)) {
                motionBtn.style.display = 'block';
            } else {
                motionBtn.style.display = 'none';
                
                // Remove the tilt device hint from info panel on desktop
                const tiltHint = Array.from(infoPanel.querySelectorAll('p')).find(p => 
                    p.textContent.includes('tilting your device'));
                if (tiltHint) {
                    tiltHint.style.display = 'none';
                }
            }
        });
    </script>
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
</body>
</html>